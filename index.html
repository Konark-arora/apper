<!DOCTYPE html><html lang="en"><head><title>index</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="index"><meta name="groc-project-path" content="README.md"><meta name="groc-github-url" content="https://github.com/asyncanup/apper"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/asyncanup/apper/blob/master/README.md">README.md</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="apper-docs">Apper Docs</h1>

<p>Plug and play, restful, real-time application framework for single page apps.</p>

[![Build Status on Travis CI] [1]] [2]
[![NPM Latest version] [3]] [4]
<!--[![Coveralls Coverage Status] [7]] [8]-->

<h2 id="app">App</h2>

<p>A regular directory becomes a valid app if it has one or more of the following:</p>

<ul>
<li>An environment settings module with the name <code>environment.js</code></li>
<li>A middleware module with the name <code>middleware.js</code></li>
<li>A socket subscription module with the name <code>sockets.js</code></li>
<li>A static content directory with the name <code>public</code></li>
<li>A routes module with the name <code>routes.js</code></li>
</ul>

<p>All of the default file/directory names above can be changed by options in 
<code>apper.json</code> file in any directory.</p>

<h2 id="install">Install</h2>

<p>For usage as command-line tool:</p>

<pre><code class="bash">$ npm install -g apper
</code></pre>

<p>For usage in code:</p>

<pre><code class="bash">$ npm install apper
</code></pre>

<h2 id="usage">Usage</h2>

<h3 id="from-command-line">From command-line</h3>

<p>Just open the shell (or command prompt) in the app directory
(with one or more of the above-mentioned files), and run:</p>

<pre><code class="bash">$ apper
</code></pre>

<p>And open <code>http://localhost:8000</code> in browser.</p>

<p>Run <code>apper -h</code> for all the command-line options.</p>

<p>A more specific deployment might look like:</p>

<pre><code class="bash">$ apper --port 8080 --address 127.0.0.0 code/src
</code></pre>

<p>Here, <code>code/src</code> is the root path of the application code, relative to current
directory from which <code>apper</code> is run. It defaults to the current directory itself.</p>

<p>To display internal logs during development (helpful), just set <code>DEBUG</code> environment
variable to <code>apper:*</code></p>

<pre><code class="bash">$ DEBUG=apper:* apper --port 8000
</code></pre>

<p>For a working example, check out <code>test/sample</code> which is used by the tests.
Just run <code>apper</code> in the shell there and read the tests to get a better understanding.</p>

<h2 id="motivation">Motivation</h2>

<p><a href="http://expressjs.com" title="Express.js">Express</a> isn't enough. It lacks structure and conventions.</p>

<p>Apper provides:</p>

<ul>
<li>Much needed <strong>structure</strong> to server-side code with strong conventions</li>
<li>Reliable <strong>directory hierarchy</strong> for code based on REST end-points</li>
<li>Design for <strong>real-time</strong> right off the bat</li>
<li>Transparent <strong>minification &amp; bundling</strong> for single page apps</li>
</ul>

<p>The core idea of <code>apper</code> is to enable easy REST api based node.js apps, especially 
useful for Single Page Applications.</p>

<p>Apper lets you create bigger apps by using smaller independent chunks as subapps.
Simply place individual subapps anywhere in the directory hierarchy, and they get
exposed under a relative base URL.</p>

<p>Nested subapps are totally cool and highly encouraged.
In fact, simply by moving a subapp directory to another directory updates the exposed 
relative URL of that subapp. No frills.</p>

<h2 id="example">Example</h2>

<h3 id="example-directory-structure">Example directory structure</h3>

<pre><code>+ root/
    - server.js (See Programmatic Usage section below)
    - routes.js (GET /login)
    + public/
        - index.html
        - main.js

    + api/
        - routes.js (GET /, POST /)

        + items/
            - middleware.js
            - routes.js (GET /, GET /last)
</code></pre>

<p><em>routes.js</em> files above are supposed to specify route handlers for paths mentioned
against them.</p>

<p>Read below for code samples for all of them.</p>

<h3 id="api-exposed-by-the-directory-structure-above">API exposed by the directory structure above</h3>

<pre><code>GET  /
GET  /login

GET  /api
POST /api

GET  /api/items
GET  /api/items/last
</code></pre>

<p>The route <code>/</code> serves <code>index.html</code> in <code>public/</code> by default.
Can be overridden by including a route <code>GET /</code> in <code>routes.js</code>.</p>

<h2 id="core-concepts">Core Concepts</h2>

<h4 id="order-of-initialization-of-modules">Order of initialization of modules</h4>

<p>The following modules get initialized on the subapp in order:</p>

<ul>
<li><code>environment.js</code> to set environment settings using <code>app.set</code> (like Express)</li>
<li><code>middleware.js</code> to setup middleware functions using <code>app.use</code> (like Express)</li>
<li><code>sockets.js</code> to setup WebSocket subscriptions between server and client</li>
<li><code>public</code> exposed as static content directory</li>
<li><code>routes.js</code> to respond to URL end-points (using <code>app.get</code>, <code>app.post</code>, etc.)</li>
</ul>

<h3 id="bigger-apps-composed-of-small-apps">Bigger apps composed of small apps</h3>

<p>The root app can contain sub-directories which are complete apps unto themselves. 
These directories become subapps of the root app (or sub APIs, if you may).</p>

<p>Subapps can be pulled out and placed anywhere in the overall directory structure.
This would make them available on the new relative url with respect to the root.</p>

<p>Every subapp directory can be started as a separated app just by running <code>apper</code> in there.</p>

<p>Due to the directory hierarchy based mounting of subapps, the base URL paths of
all subapps are decided by their position in the directory hierarchy.</p>

<p>The subapps can then register for any relative URL route after their base URL and
handle requests accordingly.</p>

<h2 id="programmatic-usage">Programmatic Usage</h2>

<h3 id="as-a-module">As a module</h3>

<p>Create a file (say, <code>server.js</code>) in your application directory</p>

<pre><code class="js">var app = require('apper')({
    port: 8000
});
app.start();
</code></pre>

<p>Then, running <code>server.js</code> will start the application on port 8000. For example:</p>

<pre><code class="bash">$ node server.js
</code></pre>

<p>To see internal logs (helpful during development), just set the environment variable <code>DEBUG</code> as follows:</p>

<pre><code class="bash">$ DEBUG=apper:* node server.js
</code></pre>

<h3 id="as-express-application">As Express application</h3>

<p>Create an application object as usual, and use <code>app.expressApp</code> as a regular express application</p>

<pre><code class="js">var app = require('apper')();
app.expressApp.listen(5000);
</code></pre>

<h3 id="as-express-middleware">As Express middleware</h3>

<p>You can use this application as middleware in your regular express app as follows:</p>

<pre><code class="js">var app = require('apper')();
myExpressApp.use(app.expressApp);
</code></pre>

<p>Mounting your <strong>apper</strong> app as an Express subapp is as easy:</p>

<pre><code class="js">var app = require('apper')();
myExpressApp.use('/blog', app.expressApp);
</code></pre>

<p>Now the <strong>apper</strong> application gets confined to <code>/blog</code> base URL.</p>

<h2 id="more-code">More Code</h2>

<h3 id="startup">Startup</h3>

<p>Apper synchronously loads its modules when you initialize it. You can start the
server by calling <code>app.start()</code>.</p>

<p>Constructor options look like this:</p>

<pre><code class="js">var app = require('apper')({
    path: '.',
    port: 8000,
    host: '0.0.0.0',

    // Not commonly used. Just use `apper.json` for the configuration
    toOpenBrowser: false,
    staticContentName: 'public',
    moduleNames: {
        environment: 'environment'
        middleware: 'middleware',
        routes: 'routes',
        sockets: 'sockets'
    },
    mountPath: ''
});
app.start();
</code></pre>

<p>The default values for the options (path/port/etc) are as shown above.
The options mean the following:</p>

<ul>
<li><code>path</code>: Path for the directory to be taken as the root application.</li>
<li><code>port</code>: Port number on which to expose the application.</li>
<li><code>host</code>: Host name to be used for the application (<code>127.0.0.1</code>, <code>localhost</code>, <code>0.0.0.0</code>, etc).</li>
<li><code>toOpenBrowser</code>: Whether to open the system default browser with the created application.</li>
<li><code>staticContentName</code>: AheName of the static content directory inside the application directory.</li>
<li><code>moduleNames.*</code>: As discussed below in Structure of Modules.</li>
<li><code>mountPath</code>: Base URL to mount this application on, if so needed. Used internally for mounting subapps.</li>
</ul>

<p>Server automatically starts a single socket.io WebSocket server that works across all subapps
but maintains separate namespaces for all communication with different subapps.</p>

<h3 id="structure-of-modules">Structure of modules</h3>

<p>Get an Express-based app object and run express methods like 
<code>app.set</code>, <code>app.use</code>, <code>app.get</code>, <code>app.post</code>, etc. on it.</p>

<p>For WebSocket requests, <code>app.sockets</code> provides the same functionality as
<code>io.sockets</code> using <a href="http://socket.io/" title="Socket.io">socket.io</a></p>

<h4 id="environmentjs">environment.js</h4>

<pre><code class="js">module.exports = function (app) {
    app.set('property', 'value');
    // Environment configuration
};
</code></pre>

<h4 id="middlewarejs">middleware.js</h4>

<pre><code class="js">module.exports = function (app) {

    app.use(function (req, res, next) {
        // middleware code
        next();
    });
};
</code></pre>

<h4 id="routesjs">routes.js</h4>

<pre><code class="js">module.exports = function (app) {

    app.get('/', function (req, res) {
        res.send('hey');
    });
};
</code></pre>

<h4 id="socketsjs">sockets.js</h4>

<pre><code class="js">module.exports = function (app) {
    app.sockets.on('connection', function (socket) {

        socket.on('hey', function (name) {
            socket.emit('Hey ' + name + '!');
        });

    }
};
</code></pre>

<h4 id="client-side-socket-code">Client-side socket code</h4>

<p>Client-side code corresponding to <code>sockets.js</code> looks as simple.</p>

<p>Just include <code>&lt;script src='/socket.io/socket.io.js'&gt;&lt;/script&gt;</code> in <code>public/index.html</code>,
and connect to the socket server like this:</p>

<pre><code class="js">var socket = io();

socket.on('connect', function () {
    alert('woohoo!');
});
</code></pre>

<p>A subapp client connects by default to its own namespace, as per its directory hierarchy.
So you won't have 2 different subapps catching each others socket events.</p>

<h2 id="configuration">Configuration</h2>

<p><code>apper.json</code> placed in root or any subapp directory controls the following
configuration for the respective app:</p>

<ul>
<li><p><code>moduleNames.environment</code> (Example: <em>'env'</em>)</p>

<p>Environment module file name for the current app</p></li>
<li><p><code>moduleNames.middleware</code> (Example: <em>'mid'</em>)</p>

<p>Middleware module file name for the current app</p></li>
<li><p><code>moduleNames.sockets</code> (Example: <em>'sock'</em>)</p>

<p>Socket subscriptions module for the current app</p></li>
<li><p><code>moduleNames.routes</code> (Example: <em>'route-definitions'</em>)</p>

<p>Routes module file name for the current app</p></li>
<li><p><code>staticContentPath</code> (Example: <em>'www'</em>)</p>

<p>Static content directory name for the current app.</p></li>
<li><p><code>dirToIgnore</code> (Example: <em>['subapp', 'another']</em>)</p>

<p>List of directories to not consider as subapps in the current app's directory.</p></li>
<li><p><code>bundle</code> (Example: <em>true</em>/<em>false</em>)</p>

<p>Whether to transparently minify and inline all JavaScript and CSS resources, 
including RequireJS modules. Cached on first use, and served as is thereon.</p>

<p>You can include <code>require-config.js</code> in RequireJS <code>baseUrl</code> directory to specify
custom RequireJS options for bundling. Usually not required.</p></li>
</ul>

<h3 id="sampleapperjsonconfigurationfile">Sample <code>apper.json</code> configuration file</h3>

<pre><code>{
    "moduleNames: {
        "environment": "env",
        "middleware": "mid",
        "sockets": "sock",
        "routes": "route-definitions"
    },
    "staticContentPath": "www",
    "dirToIgnore": ["subapp", "another"],
    "bundle": true
}
</code></pre>

<h2 id="tests">Tests</h2>

<p>To run tests yourself, install <code>mocha</code></p>

<pre><code class="bash">$ npm install
$ npm install -g mocha
</code></pre>

<p>In the project directory, run</p>

<pre><code class="bash">$ npm test
</code></pre>

<p>Check out the <code>test</code> directory for usage examples.</p>

<h2 id="license">License</h2>

<p>MIT</p>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-4830349-3', 'auto');
  ga('send', 'pageview');

</script></div></div></div></div></body></html>