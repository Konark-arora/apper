{"name":"Apper","tagline":"Plug and play, restful, real-time application framework for single page apps","body":"Apper\r\n=====\r\n\r\nPlug and play, restful, real-time application framework for single page apps.\r\n\r\n[![Build Status on Travis CI](https://api.travis-ci.org/asyncanup/apper.png)](https://travis-ci.org/asyncanup/apper \"Build Status on Travis CI\")\r\n[![NPM Latest version](http://badge.fury.io/js/apper.png)](http://badge.fury.io/js/apper \"NPM Latest Version\")\r\n\r\n\r\nApp\r\n---\r\n\r\nA regular directory becomes a valid app if it has one or more of the following:\r\n\r\n* An environment settings module with the name `environment.js`\r\n* A middleware module with the name `middleware.js`\r\n* A socket subscription module with the name `sockets.js`\r\n* A static content directory with the name `public`\r\n* A routes module with the name `routes.js`\r\n\r\nAll of the default file/directory names above can be changed by options in \r\n`apper.json` file in any directory.\r\n\r\n\r\nInstall\r\n-------\r\n\r\nFor usage as command-line tool:\r\n\r\n```bash\r\n$ npm install -g apper\r\n```\r\n\r\nFor usage in code:\r\n\r\n```bash\r\n$ npm install apper\r\n```\r\n\r\n\r\nUsage\r\n-----\r\n\r\n### From command-line\r\n\r\nJust open the shell (or command prompt) in the app directory\r\n(with one or more of the above-mentioned files), and run:\r\n\r\n```bash\r\n$ apper\r\n```\r\n\r\nAnd open `http://localhost:8000` in browser.\r\n\r\nRun `apper -h` for all the command-line options.\r\n\r\nA more specific deployment might look like:\r\n\r\n```bash\r\n$ apper --port 8080 --address 127.0.0.0 code/src\r\n```\r\n\r\nHere, `code/src` is the root path of the application code, relative to current\r\ndirectory from which `apper` is run. It defaults to the current directory itself.\r\n\r\nTo display internal logs during development (helpful), just set `DEBUG` environment\r\nvariable to `apper:*`\r\n\r\n```bash\r\n$ DEBUG=apper:* apper --port 8000\r\n```\r\n\r\nFor a working example, check out `test/sample` which is used by the tests.\r\nJust run `apper` in the shell there and read the tests to get a better understanding.\r\n\r\n\r\nMotivation\r\n----------\r\n\r\n[Express] [5] isn't enough. It lacks structure and conventions.\r\n\r\nApper provides:\r\n\r\n- Much needed **structure** to server-side code with strong conventions\r\n- Reliable **directory hierarchy** for code based on REST end-points\r\n- Design for **real-time** right off the bat\r\n- Transparent **minification & bundling** for single page apps\r\n\r\nThe core idea of `apper` is to enable easy REST api based node.js apps, especially \r\nuseful for Single Page Applications.\r\n\r\nApper lets you create bigger apps by using smaller independent chunks as subapps.\r\nSimply place individual subapps anywhere in the directory hierarchy, and they get\r\nexposed under a relative base URL.\r\n\r\nNested subapps are totally cool and highly encouraged.\r\nIn fact, simply by moving a subapp directory to another directory updates the exposed \r\nrelative URL of that subapp. No frills.\r\n\r\n\r\nExample\r\n-------\r\n\r\n### Example directory structure\r\n\r\n```\r\n+ root/\r\n.... server.js (See Programmatic Usage section below)\r\n.... routes.js (GET /login)\r\n    + public/\r\n    .... index.html\r\n    .... main.js\r\n\r\n    + api/\r\n    .... routes.js (GET /, POST /)\r\n    \r\n        + items/\r\n        .... middleware.js\r\n        .... routes.js (GET /, GET /last)\r\n```\r\n\r\n*routes.js* files above are supposed to specify route handlers for paths mentioned\r\nagainst them.\r\n\r\nRead below for code samples for all of them.\r\n\r\n### API exposed by the directory structure above\r\n\r\n```\r\nGET  /\r\nGET  /login\r\n\r\nGET  /api\r\nPOST /api\r\n\r\nGET  /api/items\r\nGET  /api/items/last\r\n```\r\n\r\nThe route `/` serves `index.html` in `public/` by default.\r\nCan be overridden by including a route `GET /` in `routes.js`.\r\n\r\n\r\nCore Concepts\r\n-------------\r\n\r\n#### Order of initialization of modules\r\n\r\nThe following modules get initialized on the subapp in order:\r\n\r\n* `environment.js` to set environment settings using `app.set` (like Express)\r\n* `middleware.js` to setup middleware functions using `app.use` (like Express)\r\n* `sockets.js` to setup WebSocket subscriptions between server and client\r\n* `public` exposed as static content directory\r\n* `routes.js` to respond to URL end-points (using `app.get`, `app.post`, etc.)\r\n\r\n\r\n### Bigger apps composed of small apps\r\n\r\nThe root app can contain sub-directories which are complete apps unto themselves. \r\nThese directories become subapps of the root app (or sub APIs, if you may).\r\n\r\nSubapps can be pulled out and placed anywhere in the overall directory structure.\r\nThis would make them available on the new relative url with respect to the root.\r\n\r\nEvery subapp directory can be started as a separated app just by running `apper` in there.\r\n\r\nDue to the directory hierarchy based mounting of subapps, the base URL paths of\r\nall subapps are decided by their position in the directory hierarchy.\r\n\r\nThe subapps can then register for any relative URL route after their base URL and\r\nhandle requests accordingly.\r\n\r\n\r\nProgrammatic Usage\r\n------------------\r\n\r\n### As a module\r\n\r\nCreate a file (say, `server.js`) in your application directory\r\n\r\n```js\r\nvar app = require('apper')({\r\n    port: 8000\r\n});\r\napp.start();\r\n```\r\n\r\nThen, running `server.js` will start the application on port 8000. For example:\r\n\r\n```bash\r\n$ node server.js\r\n```\r\n\r\nTo see internal logs (helpful during development), just set the environment variable `DEBUG` as follows:\r\n\r\n```bash\r\n$ DEBUG=apper:* node server.js\r\n```\r\n\r\n\r\n### As Express application\r\n\r\nCreate an application object as usual, and use `app.expressApp` as a regular express application\r\n\r\n```js\r\nvar app = require('apper')();\r\napp.expressApp.listen(5000);\r\n```\r\n\r\n### As Express middleware\r\n\r\nYou can use this application as middleware in your regular express app as follows:\r\n\r\n```js\r\nvar app = require('apper')();\r\nmyExpressApp.use(app.expressApp);\r\n```\r\n\r\nMounting your **apper** app as an Express subapp is as easy:\r\n\r\n```js\r\nvar app = require('apper')();\r\nmyExpressApp.use('/blog', app.expressApp);\r\n```\r\n\r\nNow the **apper** application gets confined to `/blog` base URL.\r\n\r\n\r\nMore Code\r\n---------\r\n\r\n### Startup\r\n\r\nApper synchronously loads its modules when you initialize it. You can start the\r\nserver by calling `app.start()`.\r\n\r\nConstructor options look like this:\r\n\r\n```js\r\nvar app = require('apper')({\r\n    path: '.',\r\n    port: 8000,\r\n    host: '0.0.0.0',\r\n    \r\n    // Not commonly used. Just use `apper.json` for the configuration\r\n    toOpenBrowser: false,\r\n    staticDir: 'public',\r\n    moduleNames: {\r\n        environment: 'environment'\r\n        middleware: 'middleware',\r\n        routes: 'routes',\r\n        sockets: 'sockets'\r\n    },\r\n    mountPath: ''\r\n});\r\napp.start();\r\n```\r\n\r\nThe default values for the options (path/port/etc) are as shown above.\r\nThe options mean the following:\r\n\r\n- `path`: Path for the directory to be taken as the root application.\r\n- `port`: Port number on which to expose the application.\r\n- `host`: Host name to be used for the application (`127.0.0.1`, `localhost`, `0.0.0.0`, etc).\r\n- `toOpenBrowser`: Whether to open the system default browser with the created application.\r\n- `staticDir`: Name of the static content directory.\r\n- `moduleNames.*`: As discussed below in Structure of Modules.\r\n- `mountPath`: Base URL to mount this application on. Used internally for mounting subapps.\r\n\r\nServer automatically starts a single socket.io WebSocket server that works across all subapps\r\nbut maintains separate namespaces for all communication with different subapps.\r\n\r\n\r\n### Structure of modules\r\n\r\nGet an Express-based app object and run express methods like \r\n`app.set`, `app.use`, `app.get`, `app.post`, etc. on it.\r\n\r\nFor WebSocket requests, `app.sockets` provides the same functionality as\r\n`io.sockets` using [socket.io] [6]\r\n\r\n#### environment.js\r\n\r\n```js\r\nmodule.exports = function (app) {\r\n    app.set('property', 'value');\r\n    // Environment configuration\r\n};\r\n```\r\n\r\n#### middleware.js\r\n\r\n```js\r\nmodule.exports = function (app) {\r\n    \r\n    app.use(function (req, res, next) {\r\n        // middleware code\r\n        next();\r\n    });\r\n};\r\n```\r\n\r\n#### routes.js\r\n\r\n```js\r\nmodule.exports = function (app) {\r\n    \r\n    app.get('/', function (req, res) {\r\n        res.send('hey');\r\n    });\r\n};\r\n```\r\n \r\n#### sockets.js\r\n\r\n```js\r\nmodule.exports = function (app) {\r\n    app.sockets.on('connection', function (socket) {\r\n        \r\n        socket.on('hey', function (name) {\r\n            socket.emit('Hey ' + name + '!');\r\n        });\r\n        \r\n    }\r\n};\r\n```\r\n\r\n#### Client-side socket code\r\n\r\nClient-side code corresponding to `sockets.js` looks as simple.\r\n\r\nJust include `<script src='/socket.io/socket.io.js'></script>` in `public/index.html`,\r\nand connect to the socket server like this:\r\n\r\n```js\r\nvar socket = io();\r\n\r\nsocket.on('connect', function () {\r\n    alert('woohoo!');\r\n});\r\n```\r\n\r\nA subapp client connects by default to its own namespace, as per its directory hierarchy.\r\nSo you won't have 2 different subapps catching each others socket events.\r\n\r\n\r\nConfiguration\r\n-------------\r\n\r\n`apper.json` placed in root or any subapp directory controls the following\r\nconfiguration for the respective app:\r\n\r\n* `moduleNames.environment` (Example: _'env'_)\r\n  \r\n  Environment module file name for the current app\r\n\r\n* `moduleNames.middleware` (Example: _'mid'_)\r\n  \r\n  Middleware module file name for the current app\r\n\r\n* `moduleNames.sockets` (Example: _'sock'_)\r\n  \r\n  Socket subscriptions module for the current app\r\n\r\n* `moduleNames.routes` (Example: _'route-definitions'_)\r\n  \r\n  Routes module file name for the current app\r\n\r\n* `staticDir` (Example: _'www'_)\r\n  \r\n  Static content directory name for the current app.\r\n\r\n* `dirToIgnore` (Example: _['subapp', 'another']_)\r\n  \r\n  List of directories to not consider as subapps in the current app's directory.\r\n\r\n* `bundle` (Example: _true_/_false_)\r\n  \r\n  Whether to transparently minify and inline all JavaScript and CSS resources, \r\n  including RequireJS modules. Cached on first use, and served as is thereon.\r\n  \r\n  You can include `require-config.js` in RequireJS `baseUrl` directory to specify\r\n  custom RequireJS options for bundling. Usually not required.\r\n\r\n\r\n### Sample `apper.json` configuration file\r\n\r\n```\r\n{\r\n    \"moduleNames: {\r\n        \"environment\": \"env\",\r\n        \"middleware\": \"mid\",\r\n        \"sockets\": \"sock\",\r\n        \"routes\": \"route-definitions\"\r\n    },\r\n    \"staticDir\": \"www\",\r\n    \"dirToIgnore\": [\"subapp\", \"another\"],\r\n    \"bundle\": true\r\n}\r\n```\r\n\r\n\r\nTests\r\n-----\r\n\r\nTo run tests yourself, install `mocha`\r\n\r\n```bash\r\n$ npm install\r\n$ npm install -g mocha\r\n```\r\n\r\nIn the project directory, run\r\n\r\n```bash\r\n$ npm test\r\n```\r\n\r\nCheck out the `test` directory for usage examples.\r\n\r\n\r\nLicense\r\n-------\r\n\r\nMIT\r\n\r\n\r\n[5]: http://expressjs.com \"Express.js\"\r\n[6]: http://socket.io/ \"Socket.io\"","google":"UA-4830349-3","note":"Don't delete this file! It's used internally to help with page regeneration."}